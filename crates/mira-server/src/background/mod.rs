// crates/mira-server/src/background/mod.rs
// Background workers for idle-time processing
//
// Split into two lanes:
// - Fast lane: embeddings/indexing (woken immediately by Notify)
// - Slow lane: LLM tasks (summaries, pondering, code health)

mod briefings;

pub(crate) mod change_patterns;
pub mod code_health;
pub mod diff_analysis;
pub mod documentation;
mod embeddings;
pub(crate) mod entity_extraction;
mod fast_lane;
pub(crate) mod knowledge_distillation;
pub(crate) mod memory_embeddings;
pub(crate) mod outcome_scanner;
mod pondering;
pub mod session_summaries;
mod slow_lane;
pub(crate) mod summaries;
pub(crate) mod team_monitor;
pub mod watcher;

use crate::db::pool::DatabasePool;
use crate::embeddings::EmbeddingClient;
use crate::llm::ProviderFactory;
use std::sync::Arc;
use std::time::Duration;
use tokio::sync::{Notify, watch};

pub use fast_lane::FastLaneWorker;
pub use slow_lane::SlowLaneWorker;

/// Prefix for heuristic-generated content (no LLM)
pub const HEURISTIC_PREFIX: &str = "[heuristic] ";
/// Prefix for template-generated content (no LLM)
pub const TEMPLATE_PREFIX: &str = "[template] ";

/// Check if content was generated by a fallback (not LLM)
pub fn is_fallback_content(text: &str) -> bool {
    text.starts_with(HEURISTIC_PREFIX) || text.starts_with(TEMPLATE_PREFIX)
}

/// Handle for waking the fast lane worker
#[derive(Clone)]
pub struct FastLaneNotify {
    notify: Arc<Notify>,
}

impl FastLaneNotify {
    /// Wake the fast lane worker to process pending embeddings
    pub fn wake(&self) {
        self.notify.notify_one();
    }
}

/// Spawn both background workers
///
/// The `pool` parameter is the code index pool (used by fast lane for embeddings).
/// The slow lane receives `pool` as its code_pool and needs a main_pool for
/// non-code operations (sessions, memory, LLM usage). Since the slow lane
/// currently only reads code tables and writes to main tables via the pool
/// passed here, we pass the same pool. Callers that need separate pools
/// should use `spawn_with_pools` instead.
///
/// Returns:
/// - shutdown sender (send true to stop all workers)
/// - fast lane notify handle (call .wake() after queuing embeddings)
pub fn spawn(
    pool: Arc<DatabasePool>,
    embeddings: Option<Arc<EmbeddingClient>>,
    llm_factory: Arc<ProviderFactory>,
) -> (watch::Sender<bool>, FastLaneNotify) {
    // When called with a single pool, use it for both (backwards compat for tests)
    spawn_with_pools(pool.clone(), pool, embeddings, llm_factory)
}

/// Spawn both background workers with separate main and code pools.
///
/// - `code_pool`: Used for code index operations (embeddings, symbols, vec_code)
/// - `main_pool`: Used for sessions, memory, LLM usage, and other main DB operations
pub fn spawn_with_pools(
    code_pool: Arc<DatabasePool>,
    main_pool: Arc<DatabasePool>,
    embeddings: Option<Arc<EmbeddingClient>>,
    llm_factory: Arc<ProviderFactory>,
) -> (watch::Sender<bool>, FastLaneNotify) {
    let (shutdown_tx, shutdown_rx) = watch::channel(false);
    let notify = Arc::new(Notify::new());

    // Spawn supervised fast lane worker (restarts on panic)
    {
        let code_pool = code_pool.clone();
        let embeddings = embeddings.clone();
        let shutdown_rx = shutdown_rx.clone();
        let notify = notify.clone();
        tokio::spawn(async move {
            supervise_worker("fast_lane", shutdown_rx.clone(), || {
                let worker = FastLaneWorker::new(
                    code_pool.clone(),
                    embeddings.clone(),
                    shutdown_rx.clone(),
                    notify.clone(),
                );
                tokio::spawn(async move { worker.run().await })
            })
            .await;
        });
    }

    // Spawn supervised slow lane worker (restarts on panic)
    {
        let code_pool = code_pool.clone();
        let main_pool = main_pool.clone();
        let embeddings = embeddings.clone();
        let llm_factory = llm_factory.clone();
        tokio::spawn(async move {
            supervise_worker("slow_lane", shutdown_rx.clone(), || {
                let worker = SlowLaneWorker::new(
                    main_pool.clone(),
                    code_pool.clone(),
                    embeddings.clone(),
                    llm_factory.clone(),
                    shutdown_rx.clone(),
                );
                tokio::spawn(async move { worker.run().await })
            })
            .await;
        });
    }

    let fast_lane_notify = FastLaneNotify { notify };

    (shutdown_tx, fast_lane_notify)
}

/// Supervise a background worker, restarting it if it panics.
/// Stops when the shutdown signal is received.
/// Uses exponential backoff (5s -> 10s -> 20s -> 40s -> 60s cap) with max 5 consecutive panics.
async fn supervise_worker<F>(name: &str, shutdown: watch::Receiver<bool>, spawn_fn: F)
where
    F: Fn() -> tokio::task::JoinHandle<()>,
{
    const MAX_RESTARTS: u32 = 5;
    const BASE_DELAY_SECS: u64 = 5;
    const MAX_DELAY_SECS: u64 = 60;
    const HEALTHY_RUN_SECS: u64 = 60;

    let mut consecutive_panics: u32 = 0;

    loop {
        if *shutdown.borrow() {
            break;
        }

        let start = tokio::time::Instant::now();
        let handle = spawn_fn();

        match handle.await {
            Ok(()) => {
                // Normal exit (shutdown requested inside the worker)
                break;
            }
            Err(e) if e.is_panic() => {
                // Reset backoff if the worker ran long enough to be considered healthy
                if start.elapsed() >= Duration::from_secs(HEALTHY_RUN_SECS) {
                    consecutive_panics = 0;
                }

                consecutive_panics += 1;

                if consecutive_panics > MAX_RESTARTS {
                    tracing::error!(
                        "Background worker '{}' panicked {} times consecutively. Giving up.",
                        name,
                        consecutive_panics
                    );
                    break;
                }

                let delay_secs = (BASE_DELAY_SECS * 2u64.saturating_pow(consecutive_panics - 1))
                    .min(MAX_DELAY_SECS);

                tracing::error!(
                    "Background worker '{}' panicked ({}/{}): {:?}. Restarting in {}s...",
                    name,
                    consecutive_panics,
                    MAX_RESTARTS,
                    e,
                    delay_secs
                );
                tokio::time::sleep(Duration::from_secs(delay_secs)).await;
                // Loop will restart the worker
            }
            Err(e) => {
                tracing::error!("Background worker '{}' failed: {:?}", name, e);
                break;
            }
        }
    }
}
