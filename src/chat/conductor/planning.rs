//! Plan structures for conductor orchestration
//!
//! Plans are generated by the Reasoner and executed by Chat.

use serde::{Deserialize, Serialize};

/// A complete execution plan from the Reasoner
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Plan {
    /// Human-readable summary of the plan
    pub summary: String,

    /// Ordered list of steps to execute
    pub steps: Vec<PlanStep>,

    /// Files that will be modified
    pub affected_files: Vec<String>,

    /// Estimated complexity (low/medium/high)
    pub complexity: String,

    /// Whether this plan can be executed by Chat alone
    pub chat_executable: bool,

    /// Suggested verification steps
    pub verification: Vec<String>,
}

/// A single step in the plan
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PlanStep {
    /// Step index (0-based)
    pub index: usize,

    /// What type of step this is
    pub step_type: StepType,

    /// Human-readable description
    pub description: String,

    /// Files to read for context
    pub context_files: Vec<String>,

    /// Expected tool calls for this step
    pub expected_tools: Vec<String>,

    /// Dependencies on previous steps (by index)
    pub depends_on: Vec<usize>,

    /// Diff content if this is an edit step
    #[serde(skip_serializing_if = "Option::is_none")]
    pub diff: Option<String>,

    /// Target file if this is an edit step
    #[serde(skip_serializing_if = "Option::is_none")]
    pub target_file: Option<String>,

    /// Command if this is a bash step
    #[serde(skip_serializing_if = "Option::is_none")]
    pub command: Option<String>,
}

/// Types of plan steps
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum StepType {
    /// Read files to understand context
    Read,

    /// Edit an existing file (via diff)
    Edit,

    /// Create a new file
    Create,

    /// Delete a file
    Delete,

    /// Run a shell command (build, test, etc.)
    Command,

    /// Search the codebase
    Search,

    /// Verify/validate something
    Verify,

    /// Complex operation requiring multiple tools
    Composite,
}

impl Plan {
    /// Create an empty plan
    pub fn empty() -> Self {
        Self {
            summary: String::new(),
            steps: Vec::new(),
            affected_files: Vec::new(),
            complexity: "low".into(),
            chat_executable: true,
            verification: Vec::new(),
        }
    }

    /// Get the total number of steps
    pub fn step_count(&self) -> usize {
        self.steps.len()
    }

    /// Get steps that can be executed (dependencies satisfied)
    pub fn executable_steps(&self, completed: &[usize]) -> Vec<&PlanStep> {
        self.steps
            .iter()
            .filter(|step| {
                !completed.contains(&step.index)
                    && step.depends_on.iter().all(|dep| completed.contains(dep))
            })
            .collect()
    }

    /// Check if plan is complete
    pub fn is_complete(&self, completed: &[usize]) -> bool {
        self.steps.iter().all(|s| completed.contains(&s.index))
    }

    /// Get all unique context files needed
    pub fn all_context_files(&self) -> Vec<String> {
        let mut files: Vec<String> = self
            .steps
            .iter()
            .flat_map(|s| s.context_files.iter().cloned())
            .collect();
        files.sort();
        files.dedup();
        files
    }

    /// Estimate token count for the plan
    pub fn estimated_tokens(&self) -> u32 {
        // Rough estimate: 100 tokens per step + 50 per file
        let step_tokens = self.steps.len() as u32 * 100;
        let file_tokens = self.affected_files.len() as u32 * 50;
        step_tokens + file_tokens
    }
}

impl PlanStep {
    /// Create a read step
    pub fn read(index: usize, description: &str, files: Vec<String>) -> Self {
        Self {
            index,
            step_type: StepType::Read,
            description: description.into(),
            context_files: files.clone(),
            expected_tools: vec!["Read".into()],
            depends_on: Vec::new(),
            diff: None,
            target_file: None,
            command: None,
        }
    }

    /// Create an edit step with diff
    pub fn edit(index: usize, description: &str, target: &str, diff: &str) -> Self {
        Self {
            index,
            step_type: StepType::Edit,
            description: description.into(),
            context_files: vec![target.into()],
            expected_tools: vec!["Edit".into()],
            depends_on: Vec::new(),
            diff: Some(diff.into()),
            target_file: Some(target.into()),
            command: None,
        }
    }

    /// Create a command step
    pub fn command(index: usize, description: &str, cmd: &str) -> Self {
        Self {
            index,
            step_type: StepType::Command,
            description: description.into(),
            context_files: Vec::new(),
            expected_tools: vec!["Bash".into()],
            depends_on: Vec::new(),
            diff: None,
            target_file: None,
            command: Some(cmd.into()),
        }
    }

    /// Add a dependency on another step
    pub fn depends_on(mut self, step_index: usize) -> Self {
        self.depends_on.push(step_index);
        self
    }

    /// Check if this step requires file context
    pub fn needs_context(&self) -> bool {
        !self.context_files.is_empty()
    }

    /// Check if this is a potentially dangerous operation
    pub fn is_destructive(&self) -> bool {
        match self.step_type {
            StepType::Delete => true,
            StepType::Command => {
                // Check for dangerous commands
                self.command.as_ref().map_or(false, |cmd| {
                    let cmd_lower = cmd.to_lowercase();
                    cmd_lower.contains("rm -rf")
                        || cmd_lower.contains("git push --force")
                        || cmd_lower.contains("drop table")
                        || cmd_lower.contains("truncate")
                })
            }
            _ => false,
        }
    }
}

/// Parse a plan from structured Reasoner output
pub fn parse_plan(content: &str) -> Result<Plan, String> {
    // Try to parse as JSON first
    if let Ok(plan) = serde_json::from_str::<Plan>(content) {
        return Ok(plan);
    }

    // Try to find JSON block in the content
    if let Some(start) = content.find("```json") {
        if let Some(end) = content[start + 7..].find("```") {
            let json_str = &content[start + 7..start + 7 + end];
            if let Ok(plan) = serde_json::from_str::<Plan>(json_str.trim()) {
                return Ok(plan);
            }
        }
    }

    // Try to find raw JSON object
    if let Some(start) = content.find('{') {
        if let Some(end) = content.rfind('}') {
            let json_str = &content[start..=end];
            if let Ok(plan) = serde_json::from_str::<Plan>(json_str) {
                return Ok(plan);
            }
        }
    }

    Err("Failed to parse plan from Reasoner output".into())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_plan_steps() {
        let mut plan = Plan::empty();
        plan.steps.push(PlanStep::read(0, "Read main.rs", vec!["src/main.rs".into()]));
        plan.steps.push(
            PlanStep::edit(1, "Fix bug", "src/main.rs", "@@ -10,3 +10,3 @@\n-old\n+new")
                .depends_on(0),
        );
        plan.steps.push(PlanStep::command(2, "Run tests", "cargo test").depends_on(1));

        assert_eq!(plan.step_count(), 3);

        // Initially only step 0 is executable
        let executable = plan.executable_steps(&[]);
        assert_eq!(executable.len(), 1);
        assert_eq!(executable[0].index, 0);

        // After step 0, step 1 is executable
        let executable = plan.executable_steps(&[0]);
        assert_eq!(executable.len(), 1);
        assert_eq!(executable[0].index, 1);

        // Check completion
        assert!(!plan.is_complete(&[0, 1]));
        assert!(plan.is_complete(&[0, 1, 2]));
    }

    #[test]
    fn test_parse_plan_json() {
        let json = r#"{
            "summary": "Fix the bug",
            "steps": [
                {
                    "index": 0,
                    "step_type": "read",
                    "description": "Read file",
                    "context_files": ["src/lib.rs"],
                    "expected_tools": ["Read"],
                    "depends_on": []
                }
            ],
            "affected_files": ["src/lib.rs"],
            "complexity": "low",
            "chat_executable": true,
            "verification": ["cargo test"]
        }"#;

        let plan = parse_plan(json).unwrap();
        assert_eq!(plan.summary, "Fix the bug");
        assert_eq!(plan.steps.len(), 1);
    }

    #[test]
    fn test_destructive_detection() {
        let safe = PlanStep::command(0, "Build", "cargo build");
        assert!(!safe.is_destructive());

        let danger = PlanStep::command(0, "Clean", "rm -rf /tmp/foo");
        assert!(danger.is_destructive());

        let delete = PlanStep {
            index: 0,
            step_type: StepType::Delete,
            description: "Delete file".into(),
            context_files: vec![],
            expected_tools: vec![],
            depends_on: vec![],
            diff: None,
            target_file: Some("foo.rs".into()),
            command: None,
        };
        assert!(delete.is_destructive());
    }
}
