// src/relationship/pattern_engine.rs

use anyhow::Result;
use std::sync::Arc;
use tracing::{debug, info, warn};

use crate::relationship::{LearnedPattern, storage::RelationshipStorage};
use crate::relationship::types::*;

/// Pattern engine for learning and applying behavioral patterns
pub struct PatternEngine {
    storage: Arc<RelationshipStorage>,
}

impl PatternEngine {
    pub fn new(storage: Arc<RelationshipStorage>) -> Self {
        Self { storage }
    }

    /// Apply pattern updates from conversation analysis
    pub async fn apply_pattern_updates(
        &self,
        user_id: &str,
        updates: Vec<PatternUpdate>,
    ) -> Result<()> {
        for update in updates {
            self.apply_pattern_update(user_id, update).await?;
        }
        Ok(())
    }

    /// Apply a single pattern update
    async fn apply_pattern_update(&self, user_id: &str, update: PatternUpdate) -> Result<()> {
        // Try to find existing pattern
        let patterns = self.storage
            .get_patterns_by_type(user_id, &update.pattern_type)
            .await?;

        let existing = patterns.iter()
            .find(|p| p.pattern_name == update.pattern_name);

        if let Some(existing_pattern) = existing {
            // Update existing pattern
            self.update_existing_pattern(existing_pattern, &update).await?;
        } else {
            // Create new pattern
            self.create_new_pattern(user_id, &update).await?;
        }

        Ok(())
    }

    /// Update an existing pattern
    async fn update_existing_pattern(
        &self,
        existing: &LearnedPattern,
        update: &PatternUpdate,
    ) -> Result<()> {
        let mut updated = existing.clone();
        
        // Update confidence (bounded between 0.0 and 1.0)
        updated.confidence = (updated.confidence + update.confidence_delta)
            .max(0.0)
            .min(1.0);
        
        // Update description if provided
        if !update.pattern_description.is_empty() {
            updated.pattern_description = update.pattern_description.clone();
        }
        
        // Add new example if provided
        if let Some(ref example) = update.example {
            let mut examples: Vec<String> = if let Some(ex) = &updated.examples {
                serde_json::from_str(ex).unwrap_or_default()
            } else {
                vec![]
            };
            
            examples.push(example.clone());
            
            // Keep only last 10 examples
            if examples.len() > 10 {
                let skip_count = examples.len() - 10;
                examples = examples.into_iter().skip(skip_count).collect();
            }
            
            updated.examples = Some(serde_json::to_string(&examples)?);
        }
        
        // Increment observation count
        updated.times_observed += 1;
        
        // Deprecate if confidence drops too low
        if updated.confidence < 0.2 {
            updated.deprecated = 1;
            info!(
                "Pattern '{}' deprecated due to low confidence: {:.2}",
                updated.pattern_name, updated.confidence
            );
        }
        
        self.storage.upsert_pattern(&updated).await?;
        
        debug!(
            "Updated pattern '{}' - confidence: {:.2} (Î” {:.2})",
            updated.pattern_name, updated.confidence, update.confidence_delta
        );
        
        Ok(())
    }

    /// Create a new pattern
    async fn create_new_pattern(&self, user_id: &str, update: &PatternUpdate) -> Result<()> {
        let now = chrono::Utc::now().timestamp();
        
        let examples = if let Some(ref example) = update.example {
            Some(serde_json::to_string(&vec![example.clone()])?)
        } else {
            None
        };
        
        // Start with base confidence from update (clamped to reasonable range)
        let initial_confidence = update.confidence_delta.max(0.3).min(0.7);
        
        let pattern = LearnedPattern {
            id: String::new(), // Will be generated by storage
            user_id: user_id.to_string(),
            pattern_type: update.pattern_type.clone(),
            pattern_name: update.pattern_name.clone(),
            pattern_description: update.pattern_description.clone(),
            examples,
            confidence: initial_confidence,
            times_observed: 1,
            times_applied: 0,
            applies_when: None,
            deprecated: 0,
            first_observed: now,
            last_observed: now,
            last_applied: None,
        };
        
        self.storage.upsert_pattern(&pattern).await?;
        
        info!(
            "Created new pattern '{}' (type: {}, confidence: {:.2})",
            pattern.pattern_name, pattern.pattern_type, pattern.confidence
        );
        
        Ok(())
    }

    /// Get applicable patterns for current context
    pub async fn get_applicable_patterns(
        &self,
        user_id: &str,
        pattern_types: &[&str],
        min_confidence: f64,
    ) -> Result<Vec<LearnedPattern>> {
        let mut applicable = Vec::new();
        
        for pattern_type in pattern_types {
            let patterns = self.storage
                .get_patterns_by_type(user_id, pattern_type)
                .await?;
            
            for pattern in patterns {
                if pattern.confidence >= min_confidence && pattern.deprecated == 0 {
                    applicable.push(pattern);
                }
            }
        }
        
        // Sort by confidence descending
        applicable.sort_by(|a, b| b.confidence.partial_cmp(&a.confidence).unwrap());
        
        Ok(applicable)
    }

    /// Mark a pattern as applied (used in practice)
    pub async fn mark_pattern_applied(&self, pattern_id: &str) -> Result<()> {
        self.storage.increment_pattern_applied(pattern_id).await?;
        debug!("Marked pattern {} as applied", pattern_id);
        Ok(())
    }

    /// Adjust confidence based on application outcome
    pub async fn adjust_confidence_from_outcome(
        &self,
        pattern_id: &str,
        success: bool,
    ) -> Result<()> {
        let pattern = self.storage.get_pattern(pattern_id).await?;
        
        if let Some(mut p) = pattern {
            // Adjust confidence based on outcome
            let delta = if success { 0.05 } else { -0.1 };
            p.confidence = (p.confidence + delta).max(0.0).min(1.0);
            
            // Deprecate if confidence too low
            if p.confidence < 0.2 {
                p.deprecated = 1;
                warn!("Pattern {} deprecated due to repeated failures", pattern_id);
            }
            
            self.storage.upsert_pattern(&p).await?;
            
            debug!(
                "Adjusted pattern {} confidence to {:.2} (outcome: {})",
                pattern_id, p.confidence, if success { "success" } else { "failure" }
            );
        }
        
        Ok(())
    }

    /// Get pattern summary for context loading
    pub async fn get_pattern_context(
        &self,
        user_id: &str,
        pattern_types: &[&str],
    ) -> Result<Vec<PatternContext>> {
        let patterns = self.get_applicable_patterns(user_id, pattern_types, 0.5).await?;
        
        let context: Vec<PatternContext> = patterns.iter()
            .map(|p| PatternContext {
                pattern_type: p.pattern_type.clone(),
                pattern_name: p.pattern_name.clone(),
                pattern_description: p.pattern_description.clone(),
                confidence: p.confidence,
                applies_when: p.applies_when.clone(),
            })
            .collect();
        
        Ok(context)
    }

    /// Decay confidence for patterns that haven't been observed recently
    pub async fn decay_stale_patterns(&self, user_id: &str, days_threshold: i64) -> Result<()> {
        let patterns = self.storage.get_patterns(user_id).await?;
        let now = chrono::Utc::now().timestamp();
        let threshold = now - (days_threshold * 24 * 60 * 60);
        
        let mut decayed_count = 0;
        
        for mut pattern in patterns {
            if pattern.last_observed < threshold && pattern.confidence > 0.3 {
                // Decay confidence slightly
                pattern.confidence = (pattern.confidence - 0.05).max(0.1);
                self.storage.upsert_pattern(&pattern).await?;
                decayed_count += 1;
            }
        }
        
        if decayed_count > 0 {
            info!("Decayed confidence for {} stale patterns", decayed_count);
        }
        
        Ok(())
    }
}
