name: "Plan Agent - Architecture Analysis"
description: "Test the Plan agent's ability to research and create implementation plans"
tags: ["agents", "plan", "architecture", "disabled"]
timeout_seconds: 600

setup:
  create_dirs:
    - "src/api"
    - "src/db"
  create_files:
    - path: "src/api/mod.rs"
      content: |
        // API module - exposes HTTP handlers and routing
        pub mod handlers;
        pub mod routes;

        pub use handlers::*;
        pub use routes::create_router;
    - path: "src/api/handlers.rs"
      content: |
        use serde::{Deserialize, Serialize};

        #[derive(Debug, Serialize, Deserialize)]
        pub struct UserResponse {
            pub id: i64,
            pub name: String,
            pub email: String,
        }

        pub async fn get_user(id: i64) -> UserResponse {
            // TODO: Fetch from database
            UserResponse {
                id,
                name: "Test User".to_string(),
                email: "test@example.com".to_string(),
            }
        }

        pub async fn list_users() -> Vec<UserResponse> {
            // TODO: Fetch from database
            vec![UserResponse {
                id: 1,
                name: "User 1".to_string(),
                email: "user1@example.com".to_string(),
            }]
        }

        pub async fn create_user(name: String, email: String) -> UserResponse {
            // TODO: Insert into database
            UserResponse {
                id: 2,
                name,
                email,
            }
        }
    - path: "src/api/routes.rs"
      content: |
        use super::handlers::{get_user, list_users, create_user};

        pub struct Router {
            routes: Vec<Route>,
        }

        pub struct Route {
            pub method: String,
            pub path: String,
        }

        pub fn create_router() -> Router {
            Router {
                routes: vec![
                    Route { method: "GET".into(), path: "/users".into() },
                    Route { method: "GET".into(), path: "/users/:id".into() },
                    Route { method: "POST".into(), path: "/users".into() },
                ],
            }
        }
    - path: "src/db/mod.rs"
      content: |
        // Database module - handles persistence
        pub struct Database {
            connection_string: String,
        }

        impl Database {
            pub fn new(connection_string: &str) -> Self {
                Database {
                    connection_string: connection_string.to_string(),
                }
            }

            pub async fn connect(&self) -> Result<(), String> {
                // TODO: Implement actual connection
                Ok(())
            }
        }
    - path: "src/lib.rs"
      content: |
        pub mod api;
        pub mod db;

steps:
  - name: "Plan agent designs authentication feature"
    prompt: |
      IMMEDIATELY call the spawn_agent tool right now with these exact parameters:
      - agent_type: "plan"
      - task: "Design an implementation plan for adding JWT-based authentication to the API. Analyze existing code and outline files to modify."

      Do NOT delegate this to a background session. Call spawn_agent directly in your response.
    timeout_seconds: 300
    assertions:
      - type: completed_successfully
      - type: tool_executed
        tool_name: spawn_agent
        success: true
      - type: response_contains
        text: "authentication"
      - type: response_contains
        text: "JWT"

  - name: "Plan agent analyzes error handling strategy"
    prompt: |
      IMMEDIATELY call the spawn_agent tool right now with these exact parameters:
      - agent_type: "plan"
      - task: "Create a refactoring plan for adding error handling to API handlers"

      Do NOT delegate this to a background session. Call spawn_agent directly in your response.
    timeout_seconds: 180
    assertions:
      - type: completed_successfully
      - type: tool_executed
        tool_name: spawn_agent
        success: true
      - type: response_contains
        text: "error"

cleanup:
  remove_project: true
