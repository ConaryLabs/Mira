name: "Explore Agent - Codebase Analysis"
description: "Test the Explore agent's read-only codebase exploration capabilities"
tags: ["agents", "explore", "read-only", "disabled"]
timeout_seconds: 300

setup:
  create_dirs:
    - "src"
  create_files:
    - path: "src/main.rs"
      content: |
        // Main entry point for the test application
        mod config;
        mod utils;

        use config::Config;
        use utils::{format_output, validate_input};

        fn main() {
            let config = Config::load();
            let input = get_user_input();
            if validate_input(&input) {
                let result = process(input, &config);
                println!("{}", format_output(result));
            }
        }

        fn get_user_input() -> String {
            "test input".to_string()
        }

        fn process(input: String, config: &Config) -> String {
            format!("Processed: {} with {:?}", input, config)
        }
    - path: "src/config.rs"
      content: |
        // Configuration module for application settings
        #[derive(Debug)]
        pub struct Config {
            pub debug: bool,
            pub max_retries: u32,
            pub timeout_ms: u64,
        }

        impl Config {
            pub fn load() -> Self {
                Config {
                    debug: false,
                    max_retries: 3,
                    timeout_ms: 5000,
                }
            }

            pub fn with_debug(mut self, debug: bool) -> Self {
                self.debug = debug;
                self
            }
        }
    - path: "src/utils.rs"
      content: |
        // Utility functions for input/output processing

        /// Formats the output with a prefix
        pub fn format_output(input: String) -> String {
            format!("[OUTPUT] {}", input)
        }

        /// Validates that input is non-empty and within size limits
        pub fn validate_input(input: &str) -> bool {
            !input.is_empty() && input.len() < 1000
        }

        /// Logs debug messages to stderr
        pub fn log_debug(msg: &str) {
            eprintln!("[DEBUG] {}", msg);
        }

steps:
  - name: "Spawn explore agent to find function definition"
    prompt: |
      IMMEDIATELY call the spawn_agent tool right now with these exact parameters:
      - agent_type: "explore"
      - task: "Find where the validate_input function is defined and explain what it does"

      Do NOT delegate this to a background session. Call spawn_agent directly in your response.
    timeout_seconds: 120
    assertions:
      - type: completed_successfully
      - type: tool_executed
        tool_name: spawn_agent
        success: true
      - type: response_contains
        text: "validate_input"

  - name: "Spawn explore agent to trace module imports"
    prompt: |
      IMMEDIATELY call the spawn_agent tool right now with these exact parameters:
      - agent_type: "explore"
      - task: "Analyze src/main.rs and list all modules it imports"

      Do NOT delegate this to a background session. Call spawn_agent directly in your response.
    timeout_seconds: 120
    assertions:
      - type: completed_successfully
      - type: tool_executed
        tool_name: spawn_agent
        success: true
      - type: response_contains
        text: "config"
      - type: response_contains
        text: "utils"

  - name: "Verify explore agent cannot modify files"
    prompt: |
      IMMEDIATELY call the spawn_agent tool right now with these exact parameters:
      - agent_type: "explore"
      - task: "Try to write a new function to src/utils.rs"

      The explore agent should fail to write since it is read-only.
      Do NOT delegate this to a background session. Call spawn_agent directly in your response.
    timeout_seconds: 120
    assertions:
      - type: completed_successfully
      - type: tool_executed
        tool_name: spawn_agent
        success: true
      # The file should NOT contain the new function since explore is read-only
      - type: response_not_contains
        text: "Successfully wrote"

cleanup:
  remove_project: true
