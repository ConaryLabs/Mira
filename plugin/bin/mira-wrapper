#!/bin/sh
# Mira auto-download wrapper for Claude Code plugin marketplace installs.
# Downloads the mira binary on first invocation; execs immediately on subsequent runs.
# All output goes to stderr — MCP uses stdout for the JSON protocol.

set -eu
umask 077

if [ -z "${HOME:-}" ]; then
    printf '{"error": "HOME not set"}\n'
    exit 1
fi

MIRA_VERSION="0.9.4"
# Allow version pinning via environment variable
if [ -n "${MIRA_VERSION_PIN:-}" ]; then
    MIRA_VERSION="$MIRA_VERSION_PIN"
fi

REPO="ConaryLabs/Mira"
MIRA_HOME="${HOME}/.mira"
BIN_DIR="${MIRA_HOME}/bin"
MIRA_EXE_EXT=""
OS_NAME="$(uname -s 2>/dev/null || echo "Windows")"
case "$OS_NAME" in
    MINGW*|MSYS*|CYGWIN*|Windows*) MIRA_EXE_EXT=".exe" ;;
esac
MIRA_BIN="${BIN_DIR}/mira${MIRA_EXE_EXT}"
VERSION_FILE="${BIN_DIR}/.mira-version"
UPDATE_CACHE="${MIRA_HOME}/.last-update-check"
CACHE_TTL=86400  # 24 hours

# --- Dev override: if MIRA_BIN is a symlink, the developer has linked a local
# build. Respect it unconditionally — skip version checks and auto-updates.
# To revert to managed mode, remove the symlink: rm ~/.mira/bin/mira
if [ -L "$MIRA_BIN" ] && [ -x "$MIRA_BIN" ]; then
    exec "$MIRA_BIN" "$@"
fi

# --- First-install hook fast-path: if invoked as a hook but the binary hasn't
# been downloaded yet, return a minimal valid JSON response immediately and
# trigger the download in the background. This prevents hooks from timing out
# (SessionStart has a 10s timeout) while the binary is being fetched.
is_hook_invocation=false
for arg in "$@"; do
    case "$arg" in
        hook) is_hook_invocation=true; break ;;
    esac
done

if "$is_hook_invocation" && [ ! -x "$MIRA_BIN" ]; then
    printf '{"hookSpecificOutput": {"message": "Mira is installing... features will activate next session."}}\n'
    # Trigger download in background, but only if the MCP serve invocation
    # hasn't already started downloading (wait 2s to give it a head start).
    ( sleep 2; [ ! -x "$MIRA_BIN" ] && "$0" --version >/dev/null 2>&1 || true ) &
    exit 0
fi

# --- Fast path: binary exists, version known, update cache fresh ---
if [ -x "$MIRA_BIN" ] && [ -f "$VERSION_FILE" ]; then
    installed="$(cat "$VERSION_FILE" 2>/dev/null || echo "")"
    # If pinned, only accept exact match
    if [ -n "${MIRA_VERSION_PIN:-}" ]; then
        if [ "$installed" = "$MIRA_VERSION" ]; then
            exec "$MIRA_BIN" "$@"
        fi
    else
        # Accept any installed version if update cache is fresh
        if [ -f "$UPDATE_CACHE" ]; then
            file_mtime=$(stat -c %Y "$UPDATE_CACHE" 2>/dev/null || stat -f %m "$UPDATE_CACHE" 2>/dev/null || date -r "$UPDATE_CACHE" +%s 2>/dev/null || echo 0)
            cache_age=$(( $(date +%s 2>/dev/null || echo "$file_mtime") - file_mtime ))
            if [ "$cache_age" -lt "$CACHE_TTL" ]; then
                exec "$MIRA_BIN" "$@"
            fi
        fi
        # Also fast-path if installed version matches floor (first run after install)
        if [ "$installed" = "$MIRA_VERSION" ] && [ ! -f "$UPDATE_CACHE" ]; then
            exec "$MIRA_BIN" "$@"
        fi
    fi
fi

# --- Slow path: check for updates and download if needed ---
log() { printf '%s\n' "$1" >&2; }

# Get latest version from GitHub (uses redirect, no API rate limit)
get_latest_version() {
    location=""
    # Try redirect-based check first (no rate limit)
    if command -v curl >/dev/null 2>&1; then
        location=$(curl -fsSI "https://github.com/${REPO}/releases/latest" 2>/dev/null | grep -i '^location:' | tr -d '\r') || true
    elif command -v wget >/dev/null 2>&1; then
        location=$(wget --spider -S "https://github.com/${REPO}/releases/latest" 2>&1 | grep -i 'Location:' | tail -1 | tr -d '\r') || true
    fi

    if [ -n "${location:-}" ]; then
        # Extract version from redirect URL: .../tag/vX.Y.Z -> X.Y.Z
        # Use grep -oE to extract just the version, handling trailing text from wget
        version_tag=$(echo "$location" | grep -oE '/tag/v?[0-9]+\.[0-9]+\.[0-9]+' | tail -1 | sed 's|.*/tag/v||;s|.*/tag/||')
        if [ -n "$version_tag" ]; then
            printf '%s' "$version_tag"
            return
        fi
    fi

    # Fallback: empty string signals failure
    printf ''
}

# Detect platform
detect_platform() {
    _os_name="$(uname -s 2>/dev/null || echo "Windows")"
    case "$_os_name" in
        Linux*)                    os="unknown-linux-gnu" ;;
        Darwin*)                   os="apple-darwin" ;;
        MINGW*|MSYS*|CYGWIN*|Windows*)     os="pc-windows-msvc" ;;
        *)       log "[mira] Unsupported OS: $_os_name. Install manually: https://github.com/${REPO}"; exit 1 ;;
    esac

    _arch_name="$(uname -m 2>/dev/null || echo "x86_64")"
    case "$_arch_name" in
        x86_64|amd64)   arch="x86_64" ;;
        arm64|aarch64)  arch="aarch64" ;;
        *) log "[mira] Unsupported architecture: $_arch_name"; exit 1 ;;
    esac

    printf '%s' "${arch}-${os}"
}

# Pick a download tool
fetch() {
    url="$1"
    outfile="${2:-}"
    if command -v curl >/dev/null 2>&1; then
        if [ -n "$outfile" ]; then
            curl -fsSL "$url" -o "$outfile"
        else
            curl -fsSL "$url"
        fi
    elif command -v wget >/dev/null 2>&1; then
        if [ -n "$outfile" ]; then
            wget -qO "$outfile" "$url"
        else
            wget -qO- "$url"
        fi
    else
        log "[mira] Neither curl nor wget found. Install one and retry."
        exit 1
    fi
}

# Resolve target version
installed=""
if [ -f "$VERSION_FILE" ]; then
    installed="$(cat "$VERSION_FILE" 2>/dev/null || echo "")"
fi

target="$MIRA_VERSION"  # Start with floor

if [ -z "${MIRA_VERSION_PIN:-}" ]; then
    latest="$(get_latest_version)" || true
    if [ -n "$latest" ]; then
        target="$latest"
        # Update cache timestamp
        mkdir -p "$(dirname "$UPDATE_CACHE")"
        touch "$UPDATE_CACHE"
    else
        log "[mira] Update check failed (network unavailable)."
        if [ -x "$MIRA_BIN" ] && [ -n "$installed" ]; then
            log "[mira] Using installed v${installed}."
            touch "$UPDATE_CACHE"  # Avoid re-checking immediately
            exec "$MIRA_BIN" "$@"
        fi
        # No binary installed and no network — use floor version
        log "[mira] Attempting download of v${MIRA_VERSION} (fallback)..."
    fi
else
    target="$MIRA_VERSION"  # Pinned (MIRA_VERSION was set to MIRA_VERSION_PIN above)
fi

# If already installed at target version, just update cache and go
if [ -x "$MIRA_BIN" ] && [ "$installed" = "$target" ]; then
    touch "$UPDATE_CACHE"
    printf '%s' "$target" > "${VERSION_FILE}.tmp"
    mv -f "${VERSION_FILE}.tmp" "$VERSION_FILE"
    exec "$MIRA_BIN" "$@"
fi

# Determine if this is an install or update
if [ -z "$installed" ]; then
    log "[mira] Installing Mira v${target}..."
else
    log "[mira] Updating Mira: v${installed} -> v${target}..."
fi

platform="$(detect_platform)"

# Prefer .tar.gz (available in Git Bash, sh, bash on all platforms).
# Fall back to .zip for older releases that only ship Windows .zip.
archive_ext="tar.gz"

url="https://github.com/${REPO}/releases/download/v${target}/mira-${platform}.${archive_ext}"

log "[mira] Platform: ${platform}"
log "[mira] Downloading from: ${url}"

# Create directories
mkdir -p "$BIN_DIR"

# Download and extract to a temp dir, then atomically move into place
tmp_dir="$(mktemp -d)"
trap 'rm -rf "$tmp_dir"' EXIT

archive_file="${tmp_dir}/mira.${archive_ext}"
if ! fetch "$url" "$archive_file" 2>/dev/null; then
    # .tar.gz not available — try .zip fallback (older Windows releases)
    case "$platform" in
        *windows*)
            archive_ext="zip"
            url="https://github.com/${REPO}/releases/download/v${target}/mira-${platform}.${archive_ext}"
            archive_file="${tmp_dir}/mira.${archive_ext}"
            log "[mira] tar.gz not found, trying .zip fallback..."
            fetch "$url" "$archive_file"
            ;;
        *)
            log "[mira] ERROR: Download failed: ${url}"
            exit 1
            ;;
    esac
fi

# Verify checksum BEFORE extraction — reject tampered archives early
checksum_url="https://github.com/${REPO}/releases/download/v${target}/checksums.sha256"
checksum_file="${tmp_dir}/checksums.sha256"
if fetch "$checksum_url" "$checksum_file" 2>/dev/null; then
    expected_hash=$(grep "mira-${platform}.${archive_ext}" "$checksum_file" | cut -d' ' -f1)
    if [ -z "$expected_hash" ]; then
        log "[mira] ERROR: Checksum file present but no entry for mira-${platform}.${archive_ext}"
        log "[mira] This may indicate a corrupted or tampered release."
        exit 1
    fi
    actual_hash=""
    if command -v sha256sum >/dev/null 2>&1; then
        actual_hash=$(sha256sum "$archive_file" | cut -d' ' -f1)
    elif command -v shasum >/dev/null 2>&1; then
        actual_hash=$(shasum -a 256 "$archive_file" | cut -d' ' -f1)
    fi
    if [ -z "${actual_hash:-}" ]; then
        log "[mira] Note: No checksum tool found (sha256sum/shasum), skipping verification."
    elif [ "$actual_hash" != "$expected_hash" ]; then
        log "[mira] ERROR: Checksum verification failed!"
        log "[mira] Expected: ${expected_hash}"
        log "[mira] Got:      ${actual_hash}"
        exit 1
    fi
else
    # No checksum file (older release) — proceed with warning
    log "[mira] Note: Checksum not available for this release."
fi

# Extract verified archive
if [ "$archive_ext" = "zip" ]; then
    # .zip fallback — use PowerShell on Windows (always available, unlike unzip)
    powershell.exe -NoProfile -Command "Expand-Archive -Force -Path '$(cygpath -w "$archive_file")' -DestinationPath '$(cygpath -w "$tmp_dir")'" 2>/dev/null \
        || { log "[mira] ERROR: Failed to extract .zip archive"; exit 1; }
else
    if ! tar -xz -C "$tmp_dir" -f "$archive_file"; then
        log "[mira] ERROR: Failed to extract archive: ${archive_file}"
        log "[mira] Try deleting ~/.mira/bin/mira and re-running."
        exit 1
    fi
fi

# Determine extracted binary name
src_bin="${tmp_dir}/mira${MIRA_EXE_EXT}"

# chmod not needed on Windows
if [ -z "$MIRA_EXE_EXT" ]; then
    chmod +x "$src_bin"
fi

# Atomic install — safe if multiple wrapper instances race
mv -f "$src_bin" "$MIRA_BIN"
printf '%s' "$target" > "${VERSION_FILE}.tmp"
mv -f "${VERSION_FILE}.tmp" "$VERSION_FILE"
touch "$UPDATE_CACHE"

# Strip macOS quarantine attribute if present
case "$(uname -s 2>/dev/null || echo "Windows")" in
    Darwin*) xattr -d com.apple.quarantine "$MIRA_BIN" 2>/dev/null || true ;;
esac

# Download jq if not already available (needed for statusline setup)
install_jq() {
    if [ -x "${BIN_DIR}/jq" ] || command -v jq >/dev/null 2>&1; then
        return 0
    fi
    local jq_version="1.7.1" jq_url="" jq_expected_hash="" jq_bin="${BIN_DIR}/jq"
    # URLs and SHA256 checksums for jq 1.7.1 (from jqlang/jq releases)
    case "$(uname -s 2>/dev/null || echo "Windows")" in
        Linux*)
            case "$(uname -m 2>/dev/null || echo "x86_64")" in
                x86_64|amd64)
                    jq_url="https://github.com/jqlang/jq/releases/download/jq-${jq_version}/jq-linux-amd64"
                    jq_expected_hash="5942c9b0934e510ee61eb3e30273f1b3fe2590df93933a93d7c58b81d19c8ff5" ;;
                aarch64|arm64)
                    jq_url="https://github.com/jqlang/jq/releases/download/jq-${jq_version}/jq-linux-arm64"
                    jq_expected_hash="4dd2d8a0661df0b22f1bb9a1f9830f06b6f3b8f7d91211a1ef5d7c4f06a8b4a5" ;;
            esac ;;
        Darwin*)
            case "$(uname -m 2>/dev/null || echo "x86_64")" in
                x86_64|amd64)
                    jq_url="https://github.com/jqlang/jq/releases/download/jq-${jq_version}/jq-macos-amd64"
                    jq_expected_hash="4155822bbf5ea90f5c79cf254665975eb4274d426d0709770c21774de5407443" ;;
                aarch64|arm64)
                    jq_url="https://github.com/jqlang/jq/releases/download/jq-${jq_version}/jq-macos-arm64"
                    jq_expected_hash="0bbe619e663e0de2c550be2fe0d240d076799d6f8a652b70fa04aea8a8362e8a" ;;
            esac ;;
        MINGW*|MSYS*|CYGWIN*|Windows*)
            jq_url="https://github.com/jqlang/jq/releases/download/jq-${jq_version}/jq-windows-amd64.exe"
            jq_expected_hash="7451fbbf37feffb9bf262bd97c54f0da558c63f0748e64152dd87b0a07b6d6ab"
            jq_bin="${BIN_DIR}/jq.exe" ;;
    esac
    if [ -z "$jq_url" ]; then return 1; fi
    if ! fetch "$jq_url" "$jq_bin" 2>/dev/null; then return 1; fi
    # Verify checksum
    local jq_actual_hash=""
    if command -v sha256sum >/dev/null 2>&1; then
        jq_actual_hash=$(sha256sum "$jq_bin" | cut -d' ' -f1)
    elif command -v shasum >/dev/null 2>&1; then
        jq_actual_hash=$(shasum -a 256 "$jq_bin" | cut -d' ' -f1)
    fi
    if [ -n "$jq_actual_hash" ] && [ "$jq_actual_hash" != "$jq_expected_hash" ]; then
        log "[mira] Warning: jq checksum verification failed -- removing untrusted binary"
        rm -f "$jq_bin"
        return 1
    fi
    chmod +x "$jq_bin" 2>/dev/null || true
}
install_jq 2>/dev/null || true

log "[mira] Installed Mira v${target} to ${MIRA_BIN}"
if [ -n "$installed" ] && [ "$installed" != "$target" ]; then
    log "[mira] Release notes: https://github.com/${REPO}/releases/tag/v${target}"
fi
if [ -z "$installed" ]; then
    log "[mira] To configure providers, run: ${MIRA_BIN} setup"
fi

# Ensure status line is configured on first install or when binary path changes
setup_statusline() {
    local settings_file="${HOME}/.claude/settings.json"
    local jq_bin=""

    # Find jq: bundled or system
    if [ -x "${BIN_DIR}/jq" ]; then
        jq_bin="${BIN_DIR}/jq"
    elif command -v jq >/dev/null 2>&1; then
        jq_bin="$(command -v jq)"
    else
        return  # No jq -- skip silently
    fi

    local statusline_cmd="${MIRA_BIN} statusline"
    mkdir -p "${HOME}/.claude"

    # Resolve symlink to avoid replacing it with a regular file
    if [ -L "$settings_file" ]; then
        local link_target
        link_target=$(readlink -f "$settings_file" 2>/dev/null) || {
            link_target=$(readlink "$settings_file")
            case "$link_target" in
                /*) ;;
                *)  link_target="$(cd "$(dirname "$settings_file")" && pwd)/${link_target}" ;;
            esac
        }
        settings_file="$link_target"
    fi

    # Acquire a simple lock to prevent concurrent writes from racing.
    # Stale lock check: if lock is older than 60s, assume the holder died.
    local lockdir="${MIRA_HOME}/.settings-lock"
    if ! mkdir "$lockdir" 2>/dev/null; then
        local lock_mtime
        lock_mtime=$(stat -c %Y "$lockdir" 2>/dev/null || stat -f %m "$lockdir" 2>/dev/null || echo 0)
        local lock_age=$(( $(date +%s 2>/dev/null || echo "$lock_mtime") - lock_mtime ))
        if [ "$lock_age" -gt 60 ]; then
            rmdir "$lockdir" 2>/dev/null || true
            mkdir "$lockdir" 2>/dev/null || return
        else
            return  # Another process is writing -- skip
        fi
    fi

    if [ -f "$settings_file" ]; then
        local current_cmd
        current_cmd=$("$jq_bin" -r '.statusLine.command // empty' "$settings_file" 2>/dev/null) || { rmdir "$lockdir" 2>/dev/null; return; }
        if [ -n "$current_cmd" ]; then
            # Only yield if it's a working mira statusline
            case "$current_cmd" in
                *mira*statusline*)
                    local current_bin="${current_cmd%% *}"
                    if [ -x "$current_bin" ]; then
                        rmdir "$lockdir" 2>/dev/null
                        return  # Already configured and working
                    fi
                    ;;
            esac
            # Non-mira statusline or broken path -- overwrite
        fi
        local updated
        updated=$("$jq_bin" --arg cmd "$statusline_cmd" \
            '.statusLine = {"type": "command", "command": $cmd}' "$settings_file") || { rmdir "$lockdir" 2>/dev/null; return; }
        printf '%s\n' "$updated" > "${settings_file}.tmp"
        mv -f "${settings_file}.tmp" "$settings_file"
    else
        "$jq_bin" -n --arg cmd "$statusline_cmd" \
            '{statusLine: {type: "command", command: $cmd}}' > "${settings_file}.tmp"
        mv -f "${settings_file}.tmp" "$settings_file"
    fi
    rmdir "$lockdir" 2>/dev/null || true
    log "[mira] Status line configured"
}
setup_statusline 2>/dev/null || true

# Clean up temp dir before exec (EXIT trap may not fire on exec in dash)
rm -rf "$tmp_dir" 2>/dev/null || true
trap - EXIT

exec "$MIRA_BIN" "$@"
