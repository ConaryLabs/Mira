src/api/error.rs:pub fn db_error(operation: &str, error: impl std::fmt::Debug) -> ApiError {
src/api/error.rs:pub fn fs_error(operation: &str, error: impl std::fmt::Debug) -> ApiError {
src/api/error.rs:pub fn git_error(operation: &str, error: impl std::fmt::Debug) -> ApiError {
src/api/error.rs:pub fn serde_error(operation: &str, error: impl std::fmt::Debug) -> ApiError {
src/api/error.rs:pub fn validation_error(field: &str, reason: &str) -> ApiError {
src/api/error.rs:pub fn missing_param_error(param_name: &str) -> ApiError {
src/api/error.rs:pub fn invalid_param_error(param_name: &str, reason: &str) -> ApiError {
src/api/ws/git.rs:pub async fn handle_git_command(
src/api/ws/git.rs:async fn attach_repository(params: Value, app_state: Arc<AppState>) -> ApiResult<WsServerMessage> {
src/api/ws/git.rs:async fn list_repositories(params: Value, app_state: Arc<AppState>) -> ApiResult<WsServerMessage> {
src/api/ws/git.rs:async fn clone_repository(params: Value, app_state: Arc<AppState>) -> ApiResult<WsServerMessage> {
src/api/ws/git.rs:async fn import_codebase(params: Value, app_state: Arc<AppState>) -> ApiResult<WsServerMessage> {
src/api/ws/git.rs:async fn sync_repository(params: Value, app_state: Arc<AppState>) -> ApiResult<WsServerMessage> {
src/api/ws/git.rs:async fn list_branches(params: Value, app_state: Arc<AppState>) -> ApiResult<WsServerMessage> {
src/api/ws/git.rs:async fn switch_branch(params: Value, app_state: Arc<AppState>) -> ApiResult<WsServerMessage> {
src/api/ws/git.rs:async fn list_commits(params: Value, app_state: Arc<AppState>) -> ApiResult<WsServerMessage> {
src/api/ws/git.rs:async fn get_commit_diff(params: Value, app_state: Arc<AppState>) -> ApiResult<WsServerMessage> {
src/api/ws/git.rs:async fn list_files(params: Value, app_state: Arc<AppState>) -> ApiResult<WsServerMessage> {
src/api/ws/git.rs:async fn get_file_content(params: Value, app_state: Arc<AppState>) -> ApiResult<WsServerMessage> {
src/api/ws/git.rs:async fn update_file_content(params: Value, app_state: Arc<AppState>) -> ApiResult<WsServerMessage> {
src/api/ws/git.rs:async fn get_validated_attachment(
src/api/ws/git.rs:fn attachment_to_json(attachment: &GitRepoAttachment) -> Value {
src/api/ws/git.rs:fn detect_language(file_path: &str) -> Option<String> {
src/api/ws/chat_tools/mod.rs:pub async fn handle_chat_message_with_tools(
src/api/ws/chat_tools/mod.rs:pub async fn route_tool_message(
src/api/ws/memory.rs:fn get_session_id(session_id: Option<String>) -> String {
src/api/ws/memory.rs:pub async fn handle_memory_command(
src/api/ws/memory.rs:async fn save_memory(params: Value, app_state: Arc<AppState>) -> Result<WsServerMessage> {
src/api/ws/memory.rs:async fn search_memory(params: Value, app_state: Arc<AppState>) -> Result<WsServerMessage> {
src/api/ws/memory.rs:async fn get_context(params: Value, app_state: Arc<AppState>) -> Result<WsServerMessage> {
src/api/ws/memory.rs:async fn pin_memory(params: Value, _app_state: Arc<AppState>) -> Result<WsServerMessage> {
src/api/ws/memory.rs:async fn unpin_memory(params: Value, app_state: Arc<AppState>) -> Result<WsServerMessage> {
src/api/ws/memory.rs:async fn import_memories(params: Value, app_state: Arc<AppState>) -> Result<WsServerMessage> {
src/api/ws/memory.rs:async fn export_memories(params: Value, app_state: Arc<AppState>) -> Result<WsServerMessage> {
src/api/ws/memory.rs:async fn get_recent_memories(params: Value, app_state: Arc<AppState>) -> Result<WsServerMessage> {
src/api/ws/memory.rs:async fn delete_memory(params: Value, _app_state: Arc<AppState>) -> Result<WsServerMessage> {
src/api/ws/memory.rs:async fn update_salience(params: Value, _app_state: Arc<AppState>) -> Result<WsServerMessage> {
src/api/ws/memory.rs:async fn get_memory_stats(params: Value, app_state: Arc<AppState>) -> Result<WsServerMessage> {
src/api/ws/memory.rs:async fn check_qdrant_status(app_state: Arc<AppState>) -> Result<WsServerMessage> {
src/api/ws/memory.rs:async fn trigger_rolling_summary(params: Value, app_state: Arc<AppState>) -> Result<WsServerMessage> {
src/api/ws/memory.rs:async fn trigger_snapshot_summary(params: Value, app_state: Arc<AppState>) -> Result<WsServerMessage> {
src/api/ws/mod.rs:pub fn ws_router(app_state: Arc<AppState>) -> Router {
src/api/ws/mod.rs:pub fn setup_ws_manager() -> Arc<WsManager> {
src/api/ws/mod.rs:pub async fn websocket_handler(
src/api/ws/project.rs:pub async fn handle_project_command(
src/api/ws/project.rs:async fn create_project(params: Value, app_state: Arc<AppState>) -> ApiResult<WsServerMessage> {
src/api/ws/project.rs:async fn list_projects(app_state: Arc<AppState>) -> ApiResult<WsServerMessage> {
src/api/ws/project.rs:async fn get_project(params: Value, app_state: Arc<AppState>) -> ApiResult<WsServerMessage> {
src/api/ws/project.rs:async fn update_project(params: Value, app_state: Arc<AppState>) -> ApiResult<WsServerMessage> {
src/api/ws/project.rs:async fn delete_project(params: Value, app_state: Arc<AppState>) -> ApiResult<WsServerMessage> {
src/api/ws/project.rs:async fn create_artifact(params: Value, app_state: Arc<AppState>) -> ApiResult<WsServerMessage> {
src/api/ws/project.rs:async fn get_artifact(params: Value, app_state: Arc<AppState>) -> ApiResult<WsServerMessage> {
src/api/ws/project.rs:async fn update_artifact(params: Value, app_state: Arc<AppState>) -> ApiResult<WsServerMessage> {
src/api/ws/project.rs:async fn delete_artifact(params: Value, app_state: Arc<AppState>) -> ApiResult<WsServerMessage> {
src/api/ws/project.rs:async fn list_artifacts(params: Value, app_state: Arc<AppState>) -> ApiResult<WsServerMessage> {
src/api/ws/project.rs:fn project_to_json(project: &Project) -> Value {
src/api/ws/project.rs:fn artifact_to_json(artifact: &Artifact) -> Value {
src/api/ws/project.rs:async fn validate_project_access(
src/api/ws/files.rs:pub async fn handle_file_transfer(
src/api/ws/files.rs:async fn start_upload(data: Value, _app_state: Arc<AppState>) -> ApiResult<WsServerMessage> {
src/api/ws/files.rs:async fn receive_chunk(data: Value, _app_state: Arc<AppState>) -> ApiResult<WsServerMessage> {
src/api/ws/files.rs:async fn complete_upload(data: Value, _app_state: Arc<AppState>) -> ApiResult<WsServerMessage> {  // FIX: Added underscore to unused param
src/api/ws/files.rs:async fn start_download(data: Value, _app_state: Arc<AppState>) -> ApiResult<WsServerMessage> {
src/api/ws/files.rs:async fn cleanup_session(data: Value) -> ApiResult<WsServerMessage> {
src/api/ws/files.rs:pub async fn cleanup_old_sessions() {
src/api/ws/chat/mod.rs:pub async fn ws_chat_handler(
src/api/ws/chat/mod.rs:async fn handle_socket(
src/api/ws/chat/mod.rs:pub async fn handle_simple_chat_message(
src/api/ws/chat/heartbeat.rs:async fn send_heartbeat(connection: &WebSocketConnection) -> Result<(), anyhow::Error> {
src/api/ws/chat/message_router.rs:pub fn should_use_tools(metadata: &Option<MessageMetadata>) -> bool {
src/api/ws/chat/message_router.rs:pub fn extract_file_context(metadata: &Option<MessageMetadata>) -> Option<String> {
src/state.rs:pub async fn create_app_state(
src/git/client/operations.rs:fn should_ignore_file(path: &Path) -> bool {
src/memory/sqlite/migration.rs:async fn column_exists(pool: &SqlitePool, table: &str, col: &str) -> Result<bool> {
src/memory/sqlite/migration.rs:async fn table_exists(pool: &SqlitePool, table: &str) -> Result<bool> {
src/memory/sqlite/migration.rs:async fn trigger_exists(pool: &SqlitePool, trigger: &str) -> Result<bool> {
src/memory/sqlite/migration.rs:pub async fn run_migrations(pool: &SqlitePool) -> Result<()> {
src/memory/sqlite/query.rs:pub fn embedding_f32_to_bytes(embedding: &[f32]) -> Vec<u8> {
src/memory/sqlite/query.rs:pub fn embedding_bytes_to_f32(blob: &[u8]) -> Vec<f32> {
src/memory/salience.rs:pub fn normalize_salience(raw: f32) -> f32 {
src/memory/salience.rs:pub fn rescore_salience(entry: &MemoryEntry, decay: Option<f32>) -> f32 {
src/memory/decay.rs:pub fn calculate_decayed_salience(
src/memory/decay.rs:pub fn reinforce_memory(
src/memory/decay.rs:pub fn identify_forgotten_memories(
src/memory/decay.rs:pub fn apply_batch_decay(
src/memory/decay.rs:pub fn should_include_memory(
src/memory/summarizer.rs:pub async fn summarize_memories(entries: &[MemoryEntry]) -> Option<String> {
src/memory/parallel_recall.rs:pub async fn build_context_parallel<M1, M2>(
src/memory/parallel_recall.rs:pub async fn build_context_multi_head<M1>(
src/memory/parallel_recall.rs:async fn load_recent_with_summaries<M>(
src/memory/parallel_recall.rs:fn merge_and_deduplicate_results_vec(
src/memory/parallel_recall.rs:fn merge_and_deduplicate_results(
src/memory/parallel_recall.rs:async fn compute_rerank_scores(
src/memory/parallel_recall.rs:pub async fn build_context_adaptive<M1, M2>(
src/memory/parallel_recall.rs:pub async fn build_context_with_metrics<M1, M2>(
src/memory/recall.rs:pub async fn build_context<M1, M2>(
src/memory/decay_scheduler.rs:pub fn spawn_decay_scheduler(
src/memory/decay_scheduler.rs:pub async fn run_decay_cycle(app: Arc<AppState>) -> Result<()> {
src/memory/qdrant/mapping.rs:pub fn memory_entry_to_payload(entry: &MemoryEntry) -> Value {
src/memory/qdrant/mapping.rs:pub fn payload_to_memory_entry(payload: &Value, vector: &[f32], id: Option<i64>) -> MemoryEntry {
src/memory/qdrant/search.rs:pub fn build_session_filter(session_id: &str) -> serde_json::Value {
src/memory/qdrant/search.rs:pub fn build_advanced_filter(
src/memory/qdrant/search.rs:fn millis_to_datetime(ms: i64) -> DateTime<Utc> {
src/memory/qdrant/search.rs:pub fn parse_memory_entry_from_qdrant(point: &serde_json::Value) -> Option<MemoryEntry> {
src/main.rs:async fn main() -> anyhow::Result<()> {
src/config/mod.rs:fn env_var_or<T>(key: &str, default: T) -> T
src/llm/schema.rs:pub fn function_schema() -> Value {
src/llm/schema.rs:pub fn create_evaluation_request(content: String) -> EvaluateMemoryRequest {
src/llm/emotional_weight.rs:pub async fn classify(client: &OpenAIClient, message: &str) -> Result<f32, Error> {
src/llm/intent.rs:pub fn chat_intent_function_schema() -> serde_json::Value {
src/llm/client_helpers.rs:pub fn extract_text_from_responses(resp_json: &Value) -> Option<String> {
src/llm/streaming.rs:pub async fn start_response_stream(
src/llm/streaming.rs:pub async fn stream_response(
src/llm/streaming.rs:fn norm_verbosity(v: &str) -> &'static str {
src/llm/streaming.rs:fn norm_effort(r: &str) -> &'static str {
src/llm/streaming.rs:fn truncate_for_log(s: &str, max: usize) -> String {
src/llm/streaming.rs:fn try_parse_complete_json(buf: &str) -> bool {
src/llm/client/responses.rs:pub fn extract_text_from_responses(response: &Value) -> Option<String> {
src/llm/client/responses.rs:pub fn extract_tool_calls(response: &Value) -> Vec<ToolCall> {
src/llm/client/responses.rs:pub fn extract_usage_info(response: &Value) -> Option<UsageInfo> {
src/llm/client/responses.rs:pub fn validate_response(response: &Value) -> Result<()> {
src/llm/client/responses.rs:pub fn create_request_body(
src/llm/client/responses.rs:pub fn normalize_verbosity(verbosity: &str) -> &'static str {
src/llm/client/responses.rs:pub fn normalize_reasoning_effort(effort: &str) -> &'static str {
src/llm/client/streaming.rs:pub async fn create_sse_stream(
src/llm/client/streaming.rs:pub fn sse_json_stream(
src/llm/client/streaming.rs:pub fn parse_sse_chunk(chunk_text: &str) -> Result<Option<Value>> {
src/llm/client/streaming.rs:pub fn extract_content_from_chunk(chunk: &Value) -> Option<String> {
src/llm/client/streaming.rs:pub fn is_completion_chunk(chunk: &Value) -> bool {
src/llm/client/streaming.rs:pub fn extract_tool_calls_from_chunk(chunk: &Value) -> Vec<ToolCallDelta> {
src/llm/client/streaming.rs:pub fn extract_usage_from_chunk(chunk: &Value) -> Option<StreamingUsage> {
src/services/chat_with_tools.rs:pub fn get_enabled_tools() -> Vec<Tool> {
src/prompt/builder.rs:pub fn build_system_prompt(persona: &PersonaOverlay, context: &RecallContext) -> String {
src/prompt/builder.rs:pub fn build_conversation_context(context: &RecallContext, max_messages: usize) -> String {
src/prompt/builder.rs:pub fn extract_memory_themes(context: &RecallContext) -> Vec<String> {
src/utils.rs:pub fn get_timestamp() -> u64 {
src/utils.rs:pub fn get_timestamp_millis() -> u128 {
src/tools/mira_import/schema.rs:pub fn epoch_to_utc(secs: f64) -> DateTime<Utc> {
src/tools/mira_import/main.rs:async fn main() -> anyhow::Result<()> {
src/tools/mira_import/writer.rs:pub async fn insert_messages(
src/tools/mira_import/mod.rs:pub async fn import_conversations(
src/tools/mira_import/openai.rs:pub async fn batch_memory_eval(
src/tools/mira_import/openai.rs:pub async fn batch_evaluate_messages(
src/tools/mira_import/openai.rs:fn parse_function_response(response: &serde_json::Value) -> Result<MemoryEvalResult> {
src/tools/mira_import/openai.rs:fn parse_eval_args(args_str: &str) -> Result<MemoryEvalResult> {
src/tools/mira_import/openai.rs:async fn get_embedding(client: &Client, api_key: &str, text: &str) -> Result<Vec<f32>> {
